package pacman.controllers.navya_kuchibhotla;

import pacman.controllers.Controller;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.StringTokenizer;
import pacman.game.Game;

import java.util.ArrayList;

import static pacman.game.Constants.*;

public class K_Nearest_Controller extends Controller<MOVE>{
	 
	private int c_pill; 
	private int c_pill_dist;
	private int[] c_pill_path;
	private int ghostInPath;
	private static int K = 5;
	private static int[][] Training_Data = tokenizeTrainingData(); 

	
	private static int[][] tokenizeTrainingData()
	{
		String s="";
		int c; 
		// Take input from the file
		try{
		FileInputStream fs= new FileInputStream("Training_Data.txt");
		while((c=fs.read())!=-1)
			s+=Character.toString((char)c);
		}
		catch (IOException ex){
			System.out.println("Exception while reading file: " + ex);
		}

		// Tokenize Input
		StringTokenizer strTokens=new StringTokenizer(s,"|\n\r",false);

		// count number of requests
		int numberOfTuples=(strTokens.countTokens())/3;
		System.out.println("no of req " + numberOfTuples);
		// define array sizes
		int[][] tempArray=new int[numberOfTuples][3]; 

		//store input in 2D request array
		for(int i=0;i<numberOfTuples;i++)
		{
			for(int j=0;j<3;j++)
			{
				if(strTokens.hasMoreTokens())
					tempArray[i][j]=Integer.parseInt(strTokens.nextToken());
			}
		} 
		return tempArray;

	}
	
	public MOVE getMove(Game game, long timeDue){


		int node = game.getPacmanCurrentNodeIndex();   
		System.out.println("instances  is " + Training_Data);
		analyzeState(game);
		int choice = finalChoice();

		if (choice == 0) 
			return game.getNextMoveAwayFromTarget(node, c_pill , DM.PATH);
		else 
			return game.getNextMoveTowardsTarget(node, c_pill, DM.PATH);

	}

	// evaluate choice from K = 5 nearest neighbors
	private int finalChoice() {
		 
		int[] distances = new int[K];
		int[] indexes = new int[K];
		int i;

		//initialize distances
		for (i = 0; i < K; i++)
			distances[i] = Integer.MAX_VALUE;

		System.out.println("closest pill dist is " + c_pill_dist);
		// find K closest tuples from Training Data
		int dist;
		for (i = 0; i < Training_Data.length; i++) {
			dist = (int)  (Training_Data[i][0] - c_pill_dist); 
			System.out.println("dist at " + i + " is " + dist);
			if (dist <= distances[0]) {
				System.out.println("replace distances 0 " + i + " with " + dist);
				distances[4] = distances[3];
				distances[3] = distances[2];
				distances[2] = distances[1];
				distances[1] = distances[0];
				distances[0] = dist;
				indexes[2] = indexes[1];
				indexes[1] = indexes[0];
				indexes[0] = i;
			} else if (dist <= distances[1]) {
				System.out.println("replace distances 1 " + i + " with " + dist);
				distances[4] = distances[3];
				distances[3] = distances[2];
				distances[2] = distances[1];
				distances[1] = dist;
				indexes[2] = indexes[1];
				indexes[1] = i;
			} else if (dist <= distances[2]) {
				System.out.println("replace distances 2 " + i + " with " + dist);
				distances[4] = distances[3];
				distances[3] = distances[2];
				distances[2] = dist;
				indexes[2] = i;
			}
			else if (dist <= distances[3]) {
				System.out.println("replace distances 3 " + i + " with " + dist);
				distances[4] = distances[3];
				distances[3] =  dist;
				indexes[3] = i;
			}
			else if (dist <= distances[4]) {
				System.out.println("replace distances 4 " + i + " with " + dist);
				distances[4] =  dist;
				indexes[4] = i;
			}
		}

		//add decisions of each of the K nearest instances
		// return that sum divided by K
		int sum = 0;
		for (i = 0; i < K; i++) {
			sum += Training_Data[indexes[i]][2];
		}

		//if 0, then run from nearest ghost
		//if 1, then run to nearest pill
		System.out.println("sum is " + sum + "and return value is " + sum/K);
		return Math.round(sum / K);
	}

	/**
	 * Evaluates game state
	 * Gets distance of the closest ghost and closest pill
	 *
	 * @param game
	 */
	private void analyzeState(Game game) {
		//get distance of nearest non-edible ghost and distance to nearest pill

		int current = game.getPacmanCurrentNodeIndex();

		//Get distance of nearest pill (normal or power)
		//NOTE: this section is also adapted from the StarterPacMan controller
		int[] pills = game.getActivePillsIndices();
		int[] powerPills = game.getActivePowerPillsIndices();

//		ArrayList<Integer> targets = new ArrayList<Integer>();
		
		int[] targetsArray = new int[pills.length + powerPills.length];
		System.arraycopy(pills, 0, targetsArray, 0, pills.length);
		System.arraycopy(powerPills, 0, targetsArray, pills.length, powerPills.length);

//		for (int i = 0; i < pills.length; i++)   
//			targets.add(pills[i]);
//
//		for (int i = 0; i < powerPills.length; i++)
//			targets.add(powerPills[i]);

	//	int[] targetsArray = new int[targets.size()];        //convert from ArrayList to array

		//for (int i = 0; i < targetsArray.length; i++)
		//	targetsArray[i] = targets.get(i); 
		
		c_pill = game.getClosestNodeIndexFromNodeIndex(current, targetsArray, DM.PATH);
		c_pill_path = game.getShortestPath (current, c_pill); 
		c_pill_dist = game.getShortestPathDistance(current, c_pill);

		ghostInPath = ghostFoundInPath(game,game.getShortestPath(current, c_pill));
	}

	private int ghostFoundInPath(Game game, int[] path) {
		int ghostFound = 0;
		//NOTE: this for loop is adapted from the StarterPacMan controller
		for (GHOST ghost : GHOST.values()) {
			int ghostIndex = game.getGhostCurrentNodeIndex(ghost);
			for(int i= 0; i < path.length; i++) {
				if(path[i] == ghostIndex){
					ghostFound = 1;
					break;
				}
			}
		}
		return ghostFound;	
	}
}
